
查找 数组
顺序查找--MyArray#lineSearch
二分法查找--MyArray#binarySearch


1.线索化二叉树  ---CluedBinaryTree
n个结点的二叉链表中含有n+1(2n-(n-1)=n+1)个空指针域。利用二叉链表中的空指针域，
存放指向结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）。
前驱和后继结点是按照二叉树排序方式来定义的  

节点结构为
左子节点 左节点类型  数据  右节点类型 右子节点
节点处理思路
若该节点左节点为null 获取其前置节点 复赋值为左子节点 类型标志为1
若其前置节点不为null 右子节点为null则将 前置节点的右子节点为当前节点 类型标志为1
整体  按照遍历顺序递归

好处：可以通过一个节点知道其前置和后继节点  不需要再去遍历一次

2.赫夫曼树 --HuffmanTree
 别名 ：最优二叉树
 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。
 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。
 例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。
 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。
 结点的带权路径长度（wpl）：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 5 = 10 。
 结点是指叶子结点
 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。
 在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

构建方式

先将数据按照升序排练 ，取出其中最小的两个（min1，min2 ）生成一个树a，并将树a的value值= 两个小数只和 ，将 min1和min2删除 将a添加到队列中 重复上面的操作
知道剩最后一颗树 就可以了

赫夫曼编码-HuffmanCodeForString
作用：压缩文件大小

步骤：
将需要的数据生成byte[] 查找byte[]中出现的元素并统计出现次数 保存到map中 map的key为元素 value 为次数
根据map中的数据生成 节点node  节点值为 key  节点权为value
构建赫夫曼树
根据赫夫曼树生成赫夫曼编码  遍历赫夫曼树左节点为0 右节点为1遍历累计 记录临时存储路径
遍历byte[] 将出现的元素 在赫夫曼编码中找到 构建成一个stringBuffer

stringBuffer中全是1和0的组合  对stringBuffer中数据按照二进制进行处理 (二进制 8位)
解析过后成为一个新byte[]  returnbyte 压缩完成

3。顺序二叉树

4。堆排序  HeapSorting
堆排序是基于完全二叉树的一种排序方式，其中数组可以看成是一个完全二叉树的结构
其中主节点为n 其左子节点为2n  其右子节点为2n+1
步骤：
因为其性质  生成一个数组
先找到其最右非叶子节点
通过个该节点与其叶子节点进行比较 若左子节点大于该节点或右子节点大于该节点则调换位置
同时对其左子节点进行下面节点进行排序 递归下去
完了继续下一个非叶子节点
构建出大小堆
在对数组第一个和最后一个进行交换
完了在对第一进行大小堆排序 在进行交换 遍历数组完事
排序完成
注意：上面所说的节点 指数组中的元素

5。二叉排序树  --BinarySerchTree
  二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
（2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
（3）左、右子树也分别为二叉排序树；
（4）没有键值相等的节点。
添加
  按照上面步骤累加就好
删除
    查找到要删除的节点 node
     找到他的父节点pnode
    判断node是否为叶子节点
    是 修改其父节点pnode的指向（左节点还是右节点）
    否
    从node的右子树中选取一个最小的  minnode
    删除minnode

    minnode 替换node 原来的指向关系
    minnode。l =node。l
    minnode。r=node。r
    若是根节点  直接 root = minnode
    若不是 修改其父节点pnode的指向（左节点还是右节点）

    问题：若是123567 这种树深太多


6。AVL树 --平衡二叉树   AVLTree  AVLNode
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
导致二叉树不平衡的类型有4个

需要右旋 AVLNode#rightRotation
    1创建一个新节点 值为当前节点
    2将当前节点的右子树 赋值给新节点右子树
    3把新节点的左子树设置为当前节点的左子树的右子树
    4当前节点的值替换为左节点的值
    5把当前节点的左子树设置成左子树的左子树
    6当前右子树 赋值为 新节点
触发条件：左子树的高度-右子树的高度>=2 并且 左节点的左子树的高度下>左节点的右子树的高度下

需要左旋  AVLNode#leftRotation
    1创建一个新的节点 值是当前节点的值
    2将当前节点的左子树赋值给新节点
    3把新节点的柚子树设置为当前节点的右节点的左子树
    4当前节点的替换为右节点的值
    5把当前节点的右子树设置成右子树的左子树
    6当前左子树 赋值为 新节点
触发条件：左子树的高度-右子树的高度<=-2 并且 左节点的左子树的高度下<左节点的右子树的高度下

左右旋转
    1.将当前节点左子节点左旋
    2.将当前节点右旋
触发条件：左子树的高度-右子树的高度>=2 并且 左节点的左子树的高度下<左节点的右子树的高度下

右左旋转
    1.将当前节点右子节点右旋
    2.将当前节点左旋
触发条件：左子树的高度-右子树的高度<=-2 并且 左节点的左子树的高度下>左节点的右子树的高度下

6。多路查找树

2-3树
有2种节点 二节点和三节点
二节点 有2个子节点的节点，要么有2个子节点要么没有子节点
三节点 有3个子节点的节点，要么有3个子节点要么没有子节点

2-3-4树
有2种节点 二节点和三节点
二节点 有2个子节点的节点，要么有2个子节点要么没有子节点
三节点 有3个子节点的节点，要么有3个子节点要么没有子节点
四节点 有4个子节点的节点，要么有4个子节点要么没有子节点

B树 --- BTreeTree
感觉就是多路平衡查找树
概念 ：
    B树的阶
        最大的节点的数字称为B树的阶
    关键字
        节点中存储的值
满足条件
1。每个节点最多有m课子树(m>=2)
2。除了根节点和叶子节点以外，其他每个节点至少有 m/2(向上取整)颗孩子  最多有m颗孩子
3。根节点不是叶子节点，至少有两个孩子
4。所有节点出现在同一层
5。每个非叶子节点包含n个关键字信息 (n，P0，K1，P1，K2，P2，......，Kn，Pn)。
P 值的指针节点
K为值
其中：
     a)   关键字按顺序升序排序
     b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
     c)   关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。如下图所示：


要添加关键字为GJZ  阶数M
    1。查找到需要找到需要操作的节点（在叶子节点或者根节点插入关键字）
      1.1 判断是否存在指针信息 若不存在则是根节点或者叶子节点
      1.2 在该节点添加GJZ  (跳到第2步)
      1.3 存在存在指针信息 在关键字集合中查找大于GJZ的最小值的位置 ，位置值为WZ 若没有找到WZ =-1
      1.4 若 WZ=-1 表示该节点中关键字没有比GJZ大
          所以要继续从找该节点最右面的子中寻找 并对其子节点 标注其父节点，
      1.5 若 WZ !=-1 表示该节点中关键字存在比GJZ大
          所以要继续从指针中寻找其相同位置WZ的子节点 并对其子节点标注其父节点，
          循环上述过程 直到查找到叶子节点
    2。通过获取的节点插入关键字
      2.1 在关键字集合中添加GJZ
      2.2 对添加后的关键字集合排序
      2.3 根据新的关键字集合构建新的指针集合  并赋值给当前节点指针集合，先查找GZJ在关键字集合的位置，在修改指针集合相对应的指针
      2.4 若该节需要分裂（指针数量是否等于阶数M）
      2.5 对该节点进行分裂以第 FL = M % 2 == 0 ? M / 2 : M / 2 + 1（就是分裂位置FL）个关键字进行分裂
      2.6 构建3个节点左节点lNode 根节点 root 右节点rNode
      2.7 建立3个节点的之间关系 ，向根节点中的指针集合添加lNode，rNode
      2.8 若原节点（分裂前的节点）存在子节点 则要分裂子节点给对应的lNode和rNode lNode 从第0个到FL-1  rNode 从FL到最后
      2.9 若不存在父节点 将新节点的指针和关键字集合赋值给当前节点的指针和关键字集合
      2.10 若存在父节点 为其父节点添加这个新节点

    B+树
    1。非叶节点只存储索引信息不存储数据 只是为了协助找到数据
    2。叶子节点最右遍指针指向下一个相邻的叶节点
    3。所有叶节点组成一个有序链表
    好处：通过索引信息可以通过一次查找到数据

哈希
     散列设计原则
         1.分布均匀
         2.计算简单
     散列方法
         1。直接定址法(直接存储到散列中)--分布不均匀
         2。数据分析法--比如电话号码  数据有规律的
            要事先知道数据是什么样子的
         3。平方取中法 ---数据算平方值取中间的值放到对应位置
         4。取余法
         5。随机数算法
     散列冲突的解决方案
        1。开放地址法 ----当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
           a.线性探测法
           值%长度 =n 冲突 （n+1）%长度 = n1 冲突  (n+2)%长度 = n2
           hash(key) =(hash1(key)+i)%7,i=0,1,2...,6
            好处：
            不足：会导致落在区间内的关键字Key要进行多次探测才能找到合适的位置，并且还会继续增大这个连续区间，使探测时间变得更长。
           b.二次探测法
           hash(key) =(hash1(key)+i*i)%7,i=0,1,2...,6或者hash(key) =(hash1(key)+c1*i+c2*i*i)%7,i=0,1,2...,6
           好处：解决了线性探测法的不足
           不足：关键字key散列到同一位置后探测时的路径是一样的，这样对于许多落在同一位置的关键字而言，越是后面插入的元素，探测的时间就越长
           c.再哈希法
            hash(key) =(hash1(key)+hash2(key)*i)%7,i=0,1,2...,6
        2。链地址法
        好处：算的地址在那里 数据就在那里，链表可以无限延伸
图   Vertex  Tu
    图结构
            顶点
            边
    邻接
        2顶点使用一个边就能联通  就是邻接
    路径
        从u到v的一条路径是指一个序列v0,e1,v1,e2,v2,...ek,vk，其中ei的顶点为vi及vi - 1，k称作路径的长度。
        如果它的起止顶点相同，该路径是“闭”的，反之，则称为“开”的。一条路径称为一简单路径(simple path)，如果路径中除起始与终止顶点可以重合外，所有顶点两两不等。
    有向图和无向图
        如果给图的每条边规定一个方向，那么得到的图称为有向图
    带权图


    存储
        通过数组来保存顶点信息
        邻接表保存 连接信息  (领接矩阵)

    图遍历
    ① 在图结构中，没有一个“自然”的首结点，图中任意一个顶点都可作为第一个被访问的结点。
    ② 在非连通图中，从一个顶点出发，只能够访问它所在的连通分量上的所有顶点，因此，还需考虑如何选取下一个出发点以访问图中其余的连通分量。
    ③ 在图结构中，如果有回路存在，那么一个顶点被访问之后，有可能沿回路又回到该顶点。
    ④ 在图结构中，一个顶点可以和其它多个顶点相连，当这样的顶点访问过后，存在如何选取下一个要访问的顶点的问题。

   深度优先  Tu#dfs
   广度优先  Tu#bfs

栈  MyStack# pop#  peek# push# iseEmpty
    先进后出

队列  MyQueue # poll  add get
     先近先出
链表  Node
双向链表
