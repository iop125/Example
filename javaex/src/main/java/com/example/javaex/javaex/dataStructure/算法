算法
特性
    1。有穷性（Finiteness）
    算法的有穷性是指算法必须能在执行有限个步骤之后终止；
    2。确切性(Definiteness)
    算法的每一步骤必须有确切的定义；
    3。输入项 (Input)
    一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
    4。输出项(Output)
    一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
    5。可行性(Effectiveness)
    算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。
设计要求
    1。正确性
    2。可读性
    3。健壮性
    4。效率和低存储量需求

时间复杂度
    在pascal中比较容易理解，容易计算的方法是：看看有几重for循环，只有一重则时间复杂度为O(n)，二重则为O(n^2)，依此类推，
    如果有二分则为O(logn)，二分例如快速幂、二分查找，如果一个for循环套一个二分，那么时间复杂度则为O(nlogn)。

    按数量级递增排列，常见的时间复杂度有：
    常数阶O(1),
    对数阶O( log2 n ),
    线性阶O(n),
    线性对数阶O(nlog2n),
    平方阶O(n^2)，
    立方阶O(n^3),
    k次方阶O(n^k),
    指数阶O(2^n)

    平均时间复杂度和最坏时间复杂度
空间复杂度

T(n)
    一个算法中语句执行的次数称为语句频度 记为T(n)

排序
  交换排序  ExchangeSort
      冒泡排序   maopao    稳定   O(n2)
      快速排序   quick    不稳定  O(nlogn) 平均时间, O(n2) 最坏情况; 对于大的、乱序串列一般认为是最快的已知排序
  插入排序  InsertSort
      直接插入排序  directInsertion 若后面有一个比较小的数字那么排序会慢  稳定   O(n2)
      希尔排序  shell                           不稳定 O(nlogn)
  选择排序  ChoiceSort
      简单选择排序  simpleSelectionSorting   不稳定  O(n2)
      堆排序                                 不稳定  O(nlogn)
  归并排序   MergeSort  稳定   O(n log n); 需要 O(n) 额外存储空间
  基数排序  JishuSort  稳定  O(n+k); 需要 O(n+k) 额外存储空间，k为序列中Max-Min+1
  二叉树排序  稳定   O(nlogn); 需要 O(n) 额外存储空间