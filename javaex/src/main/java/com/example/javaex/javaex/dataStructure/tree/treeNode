1.线索化二叉树  ---CluedBinaryTree
n个结点的二叉链表中含有n+1(2n-(n-1)=n+1)个空指针域。利用二叉链表中的空指针域，
存放指向结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）。
前驱和后继结点是按照二叉树排序方式来定义的  

节点结构为
左子节点 左节点类型  数据  右节点类型 右子节点
节点处理思路
若该节点左节点为null 获取其前置节点 复赋值为左子节点 类型标志为1
若其前置节点不为null 右子节点为null则将 前置节点的右子节点为当前节点 类型标志为1
整体  按照遍历顺序递归

好处：可以通过一个节点知道其前置和后继节点  不需要再去遍历一次

2.赫夫曼树 --HuffmanTree
 别名 ：最优二叉树
 路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。
 路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。
 例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。
 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。
 结点的带权路径长度（wpl）：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 5 = 10 。
 结点是指叶子结点
 当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。
 在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

构建方式

先将数据按照升序排练 ，取出其中最小的两个（min1，min2 ）生成一个树a，并将树a的value值= 两个小数只和 ，将 min1和min2删除 将a添加到队列中 重复上面的操作
知道剩最后一颗树 就可以了

赫夫曼编码-HuffmanCodeForString
作用：压缩文件大小

步骤：
将需要的数据生成byte[] 查找byte[]中出现的元素并统计出现次数 保存到map中 map的key为元素 value 为次数
根据map中的数据生成 节点node  节点值为 key  节点权为value
构建赫夫曼树
根据赫夫曼树生成赫夫曼编码  遍历赫夫曼树左节点为0 右节点为1遍历累计 记录临时存储路径
遍历byte[] 将出现的元素 在赫夫曼编码中找到 构建成一个stringBuffer

stringBuffer中全是1和0的组合  对stringBuffer中数据按照二进制进行处理 (二进制 8位)
解析过后成为一个新byte[]  returnbyte 压缩完成

3。顺序二叉树

4。堆排序  HeapSorting
堆排序是基于完全二叉树的一种排序方式，其中数组可以看成是一个完全二叉树的结构
其中主节点为n 其左子节点为2n  其右子节点为2n+1
步骤：
因为其性质  生成一个数据
先找到其最右非叶子节点
通过个该节点与其叶子节点进行比较 若左子节点大于该节点或右子节点大于该节点则调换位置
同时对其左子节点进行下面节点进行排序 递归下去
完了继续下一个非叶子节点
构建出大小堆
在对数组第一个和最后一个进行交换
完了在对第一进行大小堆排序 在进行交换 遍历数组完事
排序完成
注意：上面所说的节点 指数组中的元素

5。二叉排序树  --BinarySerchTree
  二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
（2）若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
（3）左、右子树也分别为二叉排序树；
（4）没有键值相等的节点。
添加
  按照上面步骤累加就好
删除
    查找到要删除的节点 node
     找到他的父节点pnode
    判断node是否为叶子节点
    是 修改其父节点pnode的指向（左节点还是右节点）
    否
    从node的右子树中选取一个最小的  minnode
    删除minnode

    minnode 替换node 原来的指向关系
    minnode。l =node。l
    minnode。r=node。r
    若是根节点  直接 root = minnode
    若不是 修改其父节点pnode的指向（左节点还是右节点）

    问题：若是123567 这种树深太多


6。AVL树 --平衡二叉树
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
需要通过  右旋 左旋来达到平衡

左左要右边旋转



